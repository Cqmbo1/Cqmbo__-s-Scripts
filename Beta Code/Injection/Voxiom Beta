const THREE = window.THREE;
delete window.THREE;

const guiEl = document.createElement('div');
guiEl.style.position = 'fixed';
guiEl.style.top = '50%';
guiEl.style.left = '50%';
guiEl.style.transform = 'translate(-50%, -50%)';
guiEl.style.padding = '20px';
guiEl.style.backgroundColor = 'rgba(21, 178, 186, 0.8)';
guiEl.style.color = '#fff';
guiEl.style.boxShadow = '0 0 0 10000px rgba(0, 0, 0, 0.3)';
guiEl.style.border = '33px solid rgba(255, 255, 255, 0.69)';
guiEl.style.textAlign = 'left';
guiEl.style.zIndex = '999999';
guiEl.style.display = 'none';
guiEl.style.maxWidth = '90vw';

// Flex container to hold the sections side by side
const contentWrapper = document.createElement('div');
contentWrapper.style.display = 'flex';
contentWrapper.style.justifyContent = 'space-around';
contentWrapper.style.flexWrap = 'wrap';
contentWrapper.style.gap = '30px';
contentWrapper.style.minHeight = '200px'; // Set a min-height to prevent collapsing
guiEl.appendChild(contentWrapper);

const MiscEl = document.createElement('div');
MiscEl.style.display = 'none';
guiEl.appendChild(MiscEl);

// Sidebar to show enabled settings
const enabledSettingsEl = document.createElement('div');
enabledSettingsEl.style.position = 'fixed';
enabledSettingsEl.style.top = '30%';
enabledSettingsEl.style.left = '0';
enabledSettingsEl.style.padding = '20px';
enabledSettingsEl.style.color = '#fff';
enabledSettingsEl.style.width = '200px';
enabledSettingsEl.style.maxHeight = '90vh';
enabledSettingsEl.style.overflowY = 'auto';
enabledSettingsEl.style.zIndex = '999999';
enabledSettingsEl.innerHTML = '<h3>Enabled Settings</h3>'; // Header for the enabled settings area
document.body.appendChild(enabledSettingsEl);

const targetlocked = document.createElement('div');
targetlocked.style.position = 'fixed';
targetlocked.style.top = '1%';
targetlocked.style.left = '15%';
targetlocked.style.zIndex = '999999';
targetlocked.innerText = 'TARGET LOCKED';
targetlocked.style.backgroundColor = 'black';
targetlocked.style.color = 'white'; // To make the text visible
targetlocked.style.fontSize = '32px'; // Increase font size
targetlocked.style.padding = '10px 20px'; // Add padding around the text
targetlocked.style.border = '2px solid white'; // Optional: Add a border for more visibility
document.body.appendChild(targetlocked);

let playerCount = 0;
var PlayerCounter = document.createElement('div');
PlayerCounter.style.position = 'fixed';
PlayerCounter.style.top = '1%';
PlayerCounter.style.right = '25%';
PlayerCounter.style.zIndex = '999999';
PlayerCounter.innerText = 'PlayerCount: ' + playerCount;
PlayerCounter.style.backgroundColor = 'black';
PlayerCounter.style.color = 'white'; // To make the text visible
PlayerCounter.style.fontSize = '16px'; // Increase font size
PlayerCounter.style.padding = '10px 20px'; // Add padding around the text
PlayerCounter.style.border = '2px solid white'; // Optional: Add a border for more visibility
document.body.appendChild(PlayerCounter);

// Function to update the player count dynamically
function updatePlayerCount() {
    PlayerCounter.innerText = 'PlayerCount: ' + playerCount;
}

setInterval(updatePlayerCount,1);



const IKEL = document.createElement('div');
IKEL.style.position = 'fixed';
IKEL.style.top = '40%';
IKEL.style.right = '1%';
IKEL.style.display = 'block';
IKEL.style.color = '#fff'; // White text for contrast
IKEL.style.padding = '10px'; // Add padding for better spacing
IKEL.style.borderRadius = '8px'; // Rounded corners for a cleaner look
IKEL.style.zIndex = '1000'; // Ensure it stays above other elements
IKEL.style.margin = '20px';

IKEL.innerHTML = `
  <div>
    <h1>Important Keybinds</h1>
    <br>
    <h3>z - open/close GUI</h3>
    <br>
    <h3>h - open/close Help</h3>
    <br>
    <h3>v - PlayerESP</h3>
    <br>
    <h3>b - Aimbot</h3>
    <br>
    <h3>; - WorldWireframe, Base & Dungeon Finder</h3>
    <br>
    <h3>k - AutoShoot</h3>
  </div>
`;

// Append the element to the body
document.body.appendChild(IKEL);

// Create Misc button
const MiscButton = document.createElement('button');
MiscButton.innerText = 'Misc';
MiscButton.style.position = 'fixed';
MiscButton.style.top = '0%';
MiscButton.style.right = '15%';
MiscButton.style.transform = 'translate(-50%, -50%)';
MiscButton.style.padding = '5px';
MiscButton.style.backgroundColor = 'rgba(21, 178, 186, 0.8)';
MiscButton.style.color = '#fff';
MiscButton.style.border = '5px solid rgba(255, 255, 255, 0.69)';
MiscButton.style.zIndex = '999999';

// Define the onclick action
MiscButton.onclick = () => {
    MiscEl.style.display = 'block'; // Show the Misc element

    // Hide all sections inside the contentWrapper but keep the container visible
    Array.from(contentWrapper.children).forEach((section) => {
        section.style.visibility = 'hidden'; // Hide the section's content but keep its space
    });
};

guiEl.appendChild(MiscButton);

// Create Misc button
const MainButton = document.createElement('button');
MainButton.innerText = 'Main';
MainButton.style.position = 'fixed';
MainButton.style.top = '0%';
MainButton.style.right = '25%';
MainButton.style.transform = 'translate(-50%, -50%)';
MainButton.style.padding = '5px';
MainButton.style.backgroundColor = 'rgba(21, 178, 186, 0.8)';
MainButton.style.color = '#fff';
MainButton.style.border = '5px solid rgba(255, 255, 255, 0.69)';
MainButton.style.zIndex = '9999999';

// Define the onclick action
MainButton.onclick = () => {
    MiscEl.style.display = 'none'; // Hide the Misc element

    // Show all sections inside the contentWrapper but keep the container visible
    Array.from(contentWrapper.children).forEach((section) => {
        section.style.visibility = 'visible'; // Hide the section's content but keep its space
    });
};

guiEl.appendChild(MainButton);

// Create input for real name
const fakenameinput = document.createElement('input');
fakenameinput.type = 'text';
fakenameinput.placeholder = 'Paste Real Player Name here';
fakenameinput.style.position = 'fixed';
fakenameinput.style.top = '35%';
fakenameinput.style.right = '40%';
MiscEl.appendChild(fakenameinput);

const customUsername = fakenameinput.value; // Custom Username

document.addEventListener('DOMContentLoaded',function(){
function Check() {
  const user = document.querySelector('.sc-wkwDy.gTfPhn')[0];
  if (user) {
    const username = user.textContent;
    user.textContent = customUsername;
  } else {
    setTimeout(Check, 1);
  }
}
});


const labelMapping = {
    showPlayers: 'Player ESP [V]',
    showPlayerNames: 'NameTag ESP',
    showItems: 'Item ESP [I]',
    showItemNames: 'ItemName ESP [N]',
    showBlocks: 'Block ESP [L]',
    showLines: 'PlayerLine ESP',
    showOres: 'Ore ESP [,]',
    worldWireframe: 'World Wireframe [;]',
    aimbotEnabled: 'Aimbot [B]',
    aimbotOnRightMouse: 'Aimbot On Right Click [T]',
    aimBehindWalls: 'Aim Behind Walls',
    autoFire: 'Auto Shoot [K]',
    aimAtEveryone: 'Aim At Everyone',
    autocrouch: 'AutoCrouch [Q]',
    autowalk: 'AutoWalk [Y]',
    autosprint: 'AutoSprint [U]',
    antiafk: 'AntiAfk [O]',
    adblocker: 'Adblocker',
    scaffold: 'Scaffold',
    autorespawn: 'AutoRespawn',
};

// Function to update the enabled settings list
function updateEnabledSettings() {
    const enabledSettings = Object.keys(settings).filter(
        (key) => typeof settings[key] === 'boolean' && settings[key] === true
    );

    // Clear the list before updating
    enabledSettingsEl.innerHTML = `<h3>Enabled Settings</h3>
    <br>
    `;

    enabledSettings.forEach((setting) => {
        // Only add settings that exist in labelMapping to avoid undefined values
        if (labelMapping[setting]) {
            const label = document.createElement('div');
            label.style.marginBottom = '10px';
            label.textContent = labelMapping[setting];
            enabledSettingsEl.appendChild(label);
        }
    });
}


const settings = {
    gui() {
        guiEl.style.display = guiEl.style.display === 'none' ? 'block' : 'none';

        // Clear previous content
        contentWrapper.innerHTML = '';

        MiscEl.style.display = 'none';

        // Create a close button
        const closeButton = document.createElement('button');
        closeButton.innerText = 'X';
        closeButton.style.position = 'fixed';
        closeButton.style.top = '0%';
        closeButton.style.right = '10%';
        closeButton.style.transform = 'translate(-50%, -50%)';
        closeButton.style.padding = '5px';
        closeButton.style.backgroundColor = 'rgba(21, 178, 186, 0.8)';
        closeButton.style.color = '#fff';
        closeButton.style.border = '5px solid rgba(255, 255, 255, 0.69)';
        closeButton.style.zIndex = '999999';
        closeButton.onclick = () => (guiEl.style.display = 'none');
        guiEl.appendChild(closeButton);



        // Define categories for settings
        const categories = {
            Render: ['showPlayers', 'showPlayerNames', 'showItems', 'showItemNames', 'showBlocks', 'showLines'],
            Combat: ['aimbotEnabled', 'aimbotOnRightMouse', 'aimBehindWalls', 'autoFire', 'aimAtEveryone'],
            World: ['showOres', 'worldWireframe'],
            Movement: ['autocrouch', 'autowalk', 'autosprint', 'antiafk'],
            NewandOther: ['adblocker', 'scaffold','autorespawn',],
        };

        // Function to create a section
        function createSection(title, settingsArray) {
            const section = document.createElement('div');
            section.style.flex = '2';
            section.style.minWidth = '100px';
            section.style.margin = '20px';

            const sectionTitle = document.createElement('h3');
            sectionTitle.innerText = title;
            sectionTitle.style.borderBottom = '2px solid white';
            sectionTitle.style.paddingBottom = '10px';
            sectionTitle.style.marginBottom = '10px';
            section.appendChild(sectionTitle);



        // Add a header at the top of the GUI (added only once)
        if (guiEl.querySelectorAll('guiEl-header')) {
            const header = document.createElement('h1');
            header.style.top = '0%';
            header.style.right = '50%';
            header.style.position = 'fixed';
            header.style.color = 'white';
            header.innerText = '.GUI.';
            header.className = 'guiEl-header';
            header.style.marginBottom = '30px';
            header.style.borderBottom = '2px solid white';
            header.style.paddingBottom = '0px';
            header.style.textalign = 'center';
            guiEl.appendChild(header);
        }

            settingsArray.forEach((setting) => {
                const div = document.createElement('div');
                div.className = 'checkbox';
                div.id = setting;
                div.style.marginBottom = '10px';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = setting;
                checkbox.checked = settings[setting];

                checkbox.onchange = () => {
                    settings[setting] = checkbox.checked;
                    updateEnabledSettings(); // Update the enabled settings area
                };

                const label = document.createElement('label');
                label.textContent = labelMapping[setting] || setting;
                label.htmlFor = setting;

                div.appendChild(checkbox);
                div.appendChild(label);
                section.appendChild(div);
            });

            contentWrapper.appendChild(section);
        }

        // Create and append each section
        createSection('Render', categories.Render);
        createSection('Combat', categories.Combat);
        createSection('World', categories.World);
        createSection('Movement', categories.Movement);
        createSection('New/Other', categories.NewandOther);

        // Append guiEl to the body if not already appended
        if (!document.body.contains(guiEl)) {
            document.body.appendChild(guiEl);
        }

        // Update the enabled settings list when the GUI is shown
        updateEnabledSettings();
    },

    showPlayers: true,
    showPlayerNames: true,
    showItems: true,
    showItemNames: false,
    showBlocks: true,
    showLines: true,
    showOres: true,
    worldWireframe: false,
    aimbotEnabled: true,
    aimbotOnRightMouse: false,
    aimBehindWalls: false,
    aimHeight: 0.9,
    autoFire: true,
    aimAtEveryone: false,
    autocrouch: false,
    autowalk: false,
    autosprint: true,
    antiafk: false,
    adblocker: true,
    scaffold: false,
    autorespawn: true,

    Info() {
        // Info settings
    },
    createdBy: 'Zertalious',
    adsRemovedAndModifiedBy: 'Cqmbo__',
    KeyV: 'showPlayers',
    KeyI: 'showItems',
    KeyN: 'showItemNames',
    KeyL: 'showBlocks',
    KeyB: 'aimbotEnabled',
    KeyT: 'aimbotOnRightMouse',
    KeyK: 'autoFire',
    Semicolon: 'worldWireframe',
    Comma: 'showOres',
    KeyQ: 'autocrouch',
    KeyJ: 'scaffold',
    KeyY: 'autowalk',
    KeyU: 'autosprint',
    KeyO: 'antiafk',

    editAimbotBlacklist() {
        const currList = Object.keys(aimbotBlacklist).join(', ');
        const string = prompt('Enter usernames of players for whom aimbot should be disabled.\nSeparated by single comma:', currList);

        if (string !== null) {
            aimbotBlacklist = {};
            string.split(',')
                .map((name) => name.trim().toLowerCase())
                .filter((name) => name.length > 0)
                .forEach((name) => {
                    aimbotBlacklist[name] = true;
                });

            updateBlacklistBtn();
        }
    },

    showHelp() {
        dialogEl.style.display = dialogEl.style.display === '' ? 'none' : '';
    },

    // Update UI to reflect current settings
    updateUI() {
        document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
            const settingName = checkbox.id;
            if (settingName in this) {
                checkbox.checked = this[settingName];
                updateEnabledSettings();
            }
        });
    }
};


setInterval(updateEnabledSettings,10);


// Key event listener for toggling settings
document.addEventListener('keydown', (event) => {
    const setting = settings[event.code];
    if (setting !== undefined) {
        settings[setting] = !settings[setting];
        settings.updateUI(); // Update the UI after toggling the setting
        updateEnabledSettings();
    }
        if (setting == undefined) {
        settings[setting] = !settings[setting];
        settings.updateUI(); // Update the UI after toggling the setting
            updateEnabledSettings();
    }
});

// Example for adding event listeners to checkboxes (for new UI updates)
document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
    checkbox.addEventListener('change', function() {
        const settingName = this.id;
        if (settingName in settings) {
            settings[settingName] = this.checked;
            updateEnabledSettings();
        }
                if (settingName in settings) {
            settings[settingName] = !this.checked;
                    updateEnabledSettings();
        }
    });
});






// Update UI to reflect current settings
settings.updateUI = function() {
    document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        const settingName = checkbox.id;
        if (settingName in this) {
            checkbox.checked = this[settingName];
            updateEnabledSettings();
        }
    });
};



// Key event listener
document.addEventListener('keydown', (event) => {
    const setting = settings[event.code];
    if (setting !== undefined) {
        // Toggle the setting
        settings[setting] = !settings[setting];
        settings.updateUI(); // Update the UI after toggling the setting
        updateEnabledSettings();
    }
});







document.addEventListener('keydown', (event) => {
    const setting = keyToSetting[event.code];
    if (setting) {
        // Toggle the setting
        settings[setting] = !settings[setting];
        settings[setting] = settings[setting];

        // Update checkboxes based on the toggled setting
        const checkboxes = document.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            if (checkbox.nextSibling.textContent === setting) {
                // Toggle checkbox twice to maintain the necessary state change
                checkbox.checked = !settings[setting]; // Opposite to current setting
                checkbox.checked = !checkbox.checked; // Toggle it back
                settings[setting] = !settings[setting]; // Toggle setting back to its original state
                checkbox.checked = settings[setting]; // Opposite to current setting
                checkbox.checked = checkbox.checked;// Toggle it back
                settings[setting] = settings[setting];
                updateEnabledSettings();
            }
        });

    }
});



// Example for adding event listeners to checkboxes (for new UI updates)
document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
    checkbox.addEventListener('change', function() {
        const settingName = !this.nextSibling.textContent;
        if (settingName in settings) {
            settings[settingName] = !this.checked;
            updateEnabledSettings();
        }
    });
});

document.addEventListener('keydown', (event) => {
    const setting = keyToSetting[event.code];
    if (setting) {
        // Toggle the setting
        settings[setting] = !settings[setting];
        updateEnabledSettings();

        // Update checkboxes based on the toggled setting
settings.updateUI();
    }
});


// Map keys to settings
const keyToSetting = {
    'KeyV': 'showPlayers',
    'KeyI': 'showItems',
    'KeyN': 'showItemNames',
    'KeyL': 'showBlocks',
    'KeyB': 'aimbotEnabled',
    'KeyT': 'aimbotOnRightMouse',
    'KeyK': 'autoFire',
    'Semicolon': 'worldWireframe',
    'Comma': 'showOres',
    'KeyQ': 'autocrouch',
    'KeyJ': 'scaffold',
    'KeyY': 'autowalk',
    'KeyU': 'autosprint',
    'KeyO': 'antiafk',
};


let aimbotBlacklist = {
    'Zertalious': true,
    'Zert': true
};

function updateBlacklistBtn() {
    let name = 'Edit Aimbot Blacklist';
    const n = Object.keys(aimbotBlacklist).length;
    if (n > 0) name = `${name} (${n} user${n === 1 ? '' : 's'})`;
    controllers.editAimbotBlacklist.name(name);
}

const shadowHost = document.createElement('div');
Object.assign(shadowHost.style, {
    position: 'absolute',
    top: 0,
    left: 0,
    width: '100%',
    height: '100%',
    pointerEvents: 'none'
});
const shadow = shadowHost.attachShadow({ mode: 'open' });

let enableDocumentOverride = false;

function setDocumentOverride(prop, value) {
    const old = document[prop];
    Object.defineProperty(document, prop, {
        get() {
            return enableDocumentOverride ? value : old;
        },
        configurable: true
    });
}

let gui;
let controllers;

function initGui() {
    const settingToKey = {};
    for (const key in keyToSetting) {
        settingToKey[keyToSetting[key]] = key;
    }

    const keyOverride = {
        'Semicolon': ';',
        'Comma': ','
    };

    setDocumentOverride('body', shadow);
    setDocumentOverride('head', shadow);
    setDocumentOverride('querySelector', () => null);

    enableDocumentOverride = true;
    gui = new lil.GUI();
    enableDocumentOverride = false;

    controllers = {};
    for (const key in settings) {
        let name = fromCamel(key);
        let shortKey = settingToKey[key];

        if (shortKey) {
            if (keyOverride[shortKey]) shortKey = keyOverride[shortKey];
            else if (shortKey.startsWith('Key')) shortKey = shortKey.slice(3);
            name = `[${shortKey}] ${name}`;
        }

        controllers[key] = gui.add(settings, key).name(name).listen();
    }

    controllers.aimHeight.min(0).max(1.5);
    controllers.createdBy.disable();
    controllers.adsRemovedAndModifiedBy.disable();
    controllers.KeyV.disable();
    controllers.KeyI.disable();
    controllers.KeyN.disable();
    controllers.KeyL.disable();
    controllers.KeyB.disable();
    controllers.KeyT.disable();
    controllers.KeyK.disable();
    controllers.Semicolon.disable();
    controllers.Comma.disable();
    controllers.KeyJ.disable();
    controllers.KeyQ.disable();
    controllers.KeyY.disable();
    controllers.KeyU.disable();
    controllers.KeyO.disable();
    controllers.showPlayers.hide();
    controllers.showPlayerNames.hide();
    controllers.showItems.hide();
    controllers.showItemNames.hide();
    controllers.showBlocks.hide();
    controllers.showLines.hide();
    controllers.showOres.hide();
    controllers.worldWireframe.hide();
    controllers.aimbotEnabled.hide();
    controllers.aimbotOnRightMouse.hide();
    controllers.aimBehindWalls.hide();
    controllers.autoFire.hide();
    controllers.aimAtEveryone.hide();
    controllers.autocrouch.hide();
    controllers.autowalk.hide();
    controllers.autosprint.hide();
    controllers.antiafk.hide();
    controllers.adblocker.hide();
    controllers.scaffold.hide();
    controllers.autorespawn.hide();
    controllers.createdBy.hide();
    controllers.updateUI.hide();
    controllers.KeyV.hide();
    controllers.KeyI.hide();
    controllers.KeyN.hide();
    controllers.KeyL.hide();
    controllers.KeyB.hide();
    controllers.KeyT.hide();
    controllers.KeyK.hide();
    controllers.Semicolon.hide();
    controllers.Comma.hide();
    controllers.KeyJ.hide();
    controllers.KeyQ.hide();
    controllers.KeyY.hide();
    controllers.KeyU.hide();
    controllers.KeyO.hide();
    addDescription(controllers.aimAtEveryone, 'Enable this to make aimbot work in Survival mode.');
    updateBlacklistBtn();

    const titleEl = gui.domElement.querySelector('.title');
    titleEl.innerText = `[/] Controls`;
}

function addDescription(controller, text) {
    const div = document.createElement('div');
    div.className = 'my-lil-gui-desc';
    div.innerText = text;
    controller.domElement.querySelector('.name').appendChild(div);
}

function fromCamel(text) {
    const result = text.replace(/([A-Z])/g, ' $1');
    return result.charAt(0).toUpperCase() + result.slice(1);
}

let isRightDown = false;
window.addEventListener( 'mousedown', event => {

	if ( event.button === 2 ) isRightDown = true;

} );
window.addEventListener( 'mouseup', event => {

	if ( event.button === 2 ) isRightDown = false;

} );

const geometry = new THREE.EdgesGeometry( new THREE.BoxGeometry( 1, 1, 1 ).translate( 0, 0.5, 0 ) );

const camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 1000 );

const renderer = new THREE.WebGLRenderer( {
	alpha: true,
	antialias: true
} );

renderer.setPixelRatio( window.devicePixelRatio );
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.domElement.id = 'overlayCanvas';

window.addEventListener( 'resize', () => {

	renderer.setSize( window.innerWidth, window.innerHeight );

} );


function openCustomColorPicker() {
    // Check if the color picker already exists
    if (document.getElementById('custom-color-picker')) {
        return;
    }

    // Create the custom color picker
    const customColorPicker = document.createElement('input');
    customColorPicker.type = 'color';
    customColorPicker.id = 'custom-color-picker';
    customColorPicker.style.position = 'fixed';
    customColorPicker.style.top = '45%';
    customColorPicker.style.right = '40px';
    customColorPicker.style.zIndex = '10000';
    customColorPicker.value = '#ff0000';
    MiscEl.appendChild(customColorPicker);

    // Function to apply the selected color
    function applyColor() {
        const selectedColor = customColorPicker.value;
        enemyCustomColorPickerText.style.color = selectedColor;
        colors.enemy.set(selectedColor); // Update the THREE.Color object
        colors.enemy.rawColor = selectedColor;
        console.log('Enemy color changed to:', selectedColor);
    }

    // Add event listener to the color picker for immediate update
    customColorPicker.addEventListener('input', applyColor);
}

function openTeamCustomColorPicker() {
    // Check if the color picker already exists
    if (document.getElementById('team-custom-color-picker')) {
        return;
    }

    // Create the custom color picker
    const teamCustomColorPicker = document.createElement('input');
    teamCustomColorPicker.type = 'color';
    teamCustomColorPicker.id = 'team-custom-color-picker';
    teamCustomColorPicker.style.position = 'fixed';
    teamCustomColorPicker.style.top = '50%';
    teamCustomColorPicker.style.right = '40px';
    teamCustomColorPicker.style.zIndex = '10000';
    teamCustomColorPicker.value = '#00FF00'; // Initial value corresponding to 'lime'
    MiscEl.appendChild(teamCustomColorPicker);

    // Function to apply the selected color
    function applyTeamColor() {
        const teamSelectedColor = teamCustomColorPicker.value;
        teamCustomColorPickerText.style.color = teamSelectedColor;
        colors.team.set(teamSelectedColor); // Update the THREE.Color object
        colors.team.rawColor = teamSelectedColor;
        console.log('Team color changed to:', teamSelectedColor);
    }

    // Add event listener to the color picker for immediate update
    teamCustomColorPicker.addEventListener('input', applyTeamColor);
}

function openblockCustomColorPicker() {
    // Check if the color picker already exists
    if (document.getElementById('block-custom-color-picker')) {
        return;
    }

    // Create the custom color picker
    const blockCustomColorPicker = document.createElement('input');
    blockCustomColorPicker.type = 'color';
    blockCustomColorPicker.id = 'block-custom-color-picker';
    blockCustomColorPicker.style.position = 'fixed';
    blockCustomColorPicker.style.top = '55%';
    blockCustomColorPicker.style.right = '40px';
    blockCustomColorPicker.style.zIndex = '10000';
    blockCustomColorPicker.value = '#006400'; // Initial value corresponding to 'green'
    MiscEl.appendChild(blockCustomColorPicker);

    // Function to apply the selected color
    function applyblockColor() {
        const blockSelectedColor = blockCustomColorPicker.value;
        blockCustomColorPickerText.style.color = blockSelectedColor;
        colors.block.set(blockSelectedColor); // Update the THREE.Color object
        colors.block.rawColor = blockSelectedColor;
        console.log('block color changed to:', blockSelectedColor);
    }

    // Add event listener to the color picker for immediate update
    blockCustomColorPicker.addEventListener('input', applyblockColor);
}

function openitemCustomColorPicker() {
    // Check if the color picker already exists
    if (document.getElementById('item-custom-color-picker')) {
        return;
    }

    // Create the custom color picker
    const itemCustomColorPicker = document.createElement('input');
    itemCustomColorPicker.type = 'color';
    itemCustomColorPicker.id = 'item-custom-color-picker';
    itemCustomColorPicker.style.position = 'fixed';
    itemCustomColorPicker.style.top = '60%';
    itemCustomColorPicker.style.right = '40px';
    itemCustomColorPicker.style.zIndex = '10000';
    itemCustomColorPicker.value = '#D4AF37'; // Initial value corresponding to 'gold'
    MiscEl.appendChild(itemCustomColorPicker);

    // Function to apply the selected color
    function applyitemColor() {
        const itemSelectedColor = itemCustomColorPicker.value;
        itemCustomColorPickerText.style.color = itemSelectedColor;
        colors.item.set(itemSelectedColor); // Update the THREE.Color object
        colors.item.rawColor = itemSelectedColor;
        console.log('item color changed to:', itemSelectedColor);
    }

    // Add event listener to the color picker for immediate update
    itemCustomColorPicker.addEventListener('input', applyitemColor);
}

// Object to store colors
const colors = {
    enemy: new THREE.Color('red'), // Initialize with THREE.Color object
    team: new THREE.Color('lime'),
    block: new THREE.Color('green'),
    item: new THREE.Color('gold')
};

// Call the function to open the custom color picker
openCustomColorPicker();
openTeamCustomColorPicker();
openblockCustomColorPicker();
openitemCustomColorPicker();

// Create the label text next to the color picker
const enemyCustomColorPickerText = document.createElement('span');
enemyCustomColorPickerText.id = 'enemy-custom-color-picker-text';
enemyCustomColorPickerText.style.position = 'fixed';
enemyCustomColorPickerText.style.top = '45%';
enemyCustomColorPickerText.style.right = '100px';
enemyCustomColorPickerText.style.zIndex = '10000';
enemyCustomColorPickerText.textContent = 'Enemy Color:';

// Set the color of the text to match colors.enemy
enemyCustomColorPickerText.style.color = colors.enemy.getStyle();

MiscEl.appendChild(enemyCustomColorPickerText);


// Create the label text next to the color picker
const teamCustomColorPickerText = document.createElement('span');
teamCustomColorPickerText.id = 'team-custom-color-picker-text';
teamCustomColorPickerText.style.position = 'fixed';
teamCustomColorPickerText.style.top = '50%';
teamCustomColorPickerText.style.right = '100px';
teamCustomColorPickerText.style.zIndex = '10000';
teamCustomColorPickerText.textContent = 'Team Color:';

// Set the color of the text to match colors.team
teamCustomColorPickerText.style.color = colors.team.getStyle();

MiscEl.appendChild(teamCustomColorPickerText);


// Create the label text next to the color picker
const blockCustomColorPickerText = document.createElement('span');
blockCustomColorPickerText.id = 'block-custom-color-picker-text';
blockCustomColorPickerText.style.position = 'fixed';
blockCustomColorPickerText.style.top = '55%';
blockCustomColorPickerText.style.right = '100px';
blockCustomColorPickerText.style.zIndex = '10000';
blockCustomColorPickerText.textContent = 'Block Color:';

// Set the color of the text to match colors.block
blockCustomColorPickerText.style.color = colors.block.getStyle();

MiscEl.appendChild(blockCustomColorPickerText);


// Create the label text next to the color picker
const itemCustomColorPickerText = document.createElement('span');
itemCustomColorPickerText.id = 'item-custom-color-picker-text';
itemCustomColorPickerText.style.position = 'fixed';
itemCustomColorPickerText.style.top = '60%';
itemCustomColorPickerText.style.right = '100px';
itemCustomColorPickerText.style.zIndex = '10000';
itemCustomColorPickerText.textContent = 'Item Color:';

// Set the color of the text to match colors.item
itemCustomColorPickerText.style.color = colors.item.getStyle();

MiscEl.appendChild(itemCustomColorPickerText);


function MyMaterial(color) {
    return new THREE.RawShaderMaterial({
        vertexShader: `

		attribute vec3 position;

		uniform mat4 projectionMatrix;
		uniform mat4 modelViewMatrix;

		void main() {

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			gl_Position.z = 1.0;

		}

		`,
        fragmentShader: `

		precision mediump float;

		uniform vec3 color;

		void main() {

			gl_FragColor = vec4( color, 1.0 );

		}

		`,
        uniforms: {
            color: { value: color }
        }
    });
}


let target;
let gameCamera;

let projectionMatrixKey;
let matrixWorldKey;
let elementsKey;

function inject() {

	Object.defineProperty( Object.prototype, 'overrideMaterial', {
		set( value ) {

			setTimeout( () => checkScene( this ), 0 );
			this._overrideMaterial = value;

		},
		get() {

			return this._overrideMaterial;

		},
		configurable: true
	} );

	Object.defineProperty( Object.prototype, 'far', {
		set( value ) {

			this._far = value;

		},
		get() {

			checkCamera( this );
			return this._far;

		},
		configurable: true
	} );

}

const postRunName = Math.random().toString(32).slice(0, 10).toUpperCase();

window[postRunName] = function () {
	const CTX = CanvasRenderingContext2D.prototype;
	CTX.fillText = new Proxy( CTX.fillText, {
		apply( target, ctx, [ text ] ) {

			ctx.canvas.lastText = text;

			return Reflect.apply( ...arguments );

		}
	} );

	const WebGL = WebGLRenderingContext.prototype;

	const blocks = [
		[ 0, 3 ],
		[ 1, 3 ],
		[ 4, 2 ],
		[ 5, 2 ],
		[ 7, 3 ],

		[ 2, 2 ],

		[ 0, 4 ], [ 1, 4 ], [ 2, 4 ],
		[ 0, 5 ], [ 1, 5 ], [ 2, 5 ],
		[ 0, 6 ], [ 1, 6 ], [ 2, 6 ]
	];
	const blockCheck = blocks.map( ( [ x, y ] ) => `( p.x == ${x.toFixed( 1 )} && p.y == ${y.toFixed( 1 )} )` ).join( ' || ' );

	WebGL.shaderSource = new Proxy( WebGL.shaderSource, {
		apply( target, thisArgs, args ) {

			let [ shader, src ] = args;

			if ( src.indexOf( 'vRealUv = realUv;' ) > - 1 ) {

				src = src.replace( 'void main()', `

				uniform bool showOres;
				uniform float currTime;

				void main()` )
				.replace( 'vRealUv = realUv;', `vRealUv = realUv;

				float atlasDim = 16.0;
				float tilePosX = max(0.01, min(0.99, fract(vRealUv.z)));
				float tilePosY = max(0.01, min(0.99, fract(vRealUv.w)));
				vec2 uv = vec2(vRealUv.x * (1.0 / atlasDim) + tilePosX * (1.0 / atlasDim), vRealUv.y * (1.0 / atlasDim) + tilePosY * (1.0 / atlasDim));

				if ( showOres ) {

					vec2 p = uv * ( atlasDim - 1.0 );
					p.x = fract( p.x ) > 0.5 ? ceil( p.x ) : floor( p.x );
					p.y = fract( p.y ) > 0.5 ? ceil( p.y ) : floor( p.y );
					if ( ${blockCheck} ) {

						gl_Position.z = 0.99;
						vAo += 0.25 + abs( sin( currTime * 2.0 ) ) * 0.5;

					}

				}

				` );

				shader.isChunkShader = true;

			}

			args[ 1 ] = src;

			return Reflect.apply( ...arguments );

		}
	} );

	WebGL.attachShader = new Proxy( WebGL.attachShader, {
		apply( target, thisArgs, [ program, shader ] ) {

			if ( shader.isChunkShader ) program.isChunkProgram = true;

			return Reflect.apply( ...arguments );

		}
	} );

	WebGL.useProgram = new Proxy( WebGL.useProgram, {
		apply( target, gl, [ program ] ) {

			Reflect.apply( ...arguments );

			if ( program.isChunkProgram ) {

				if ( ! program.initialized ) {

					program.uniforms = {
						showOres: gl.getUniformLocation( program, 'showOres' ),
						currTime: gl.getUniformLocation( program, 'currTime' )
					};
					program.initialized = true;

				}

				gl.uniform1i( program.uniforms.showOres, settings.showOres );
				gl.uniform1f( program.uniforms.currTime, performance.now() / 1000 );

			}

		}
	} );

	const props = [ 'far', 'overrideMaterial' ];

	document.addEventListener = new Proxy( document.addEventListener, {
		apply( target, thisArgs, args ) {

			if ( args[ 0 ].startsWith( 'vis' ) ) {

				for ( const prop of props ) delete Object.prototype[ prop ];

				const old = window.setInterval;
				window.setInterval = function () {};

				setTimeout( function () {

					window.setInterval = old;
					inject();

				}, 0 );

			}

			return Reflect.apply( ...arguments );

		}
	} );

	Object.getOwnPropertyNames = new Proxy( Object.getOwnPropertyNames, {
		apply( target, thisArgs, [ object ] ) {

			const list = Reflect.apply( ...arguments );

			if ( object === Object.prototype ) {

				props.forEach( prop => removeFromList( list, prop ) );

			}

			return list;

		}
	} );

	Object.prototype.hasOwnProperty = new Proxy( Object.prototype.hasOwnProperty, {
		apply( target, thisArgs, [ prop ] ) {

			if ( props.includes( prop ) ) return false;

			return Reflect.apply( ...arguments );

		}
	} );

	Object.getOwnPropertyDescriptor = new Proxy( Object.getOwnPropertyDescriptor, {
		apply( target, thisArgs, [ object, prop ] ) {

			if ( object === Object.prototype && props.includes( prop ) ) return undefined;

			return Reflect.apply( ...arguments );

		}
	} );

	Object.getOwnPropertyDescriptors = new Proxy( Object.getOwnPropertyDescriptors, {
		apply( target, thisArgs, [ object ] ) {

			const result = Reflect.apply( ...arguments );

			if ( object === Object.prototype ) {

				props.forEach( prop => ( delete result[ prop ] ) );

			}

			return result;

		}
	} );

	addElements();
	tryToAddElements();
}

function removeQueries() {

	const url = new URL( window.location.href );
	url.searchParams.delete( 'showAd' );
	url.searchParams.delete( 'scriptVersion' );

	window.history.pushState( null, '', url.href );

}

function removeFromList( list, item ) {

	const index = list.indexOf( item );
	if ( index > - 1 ) list.splice( index, 1 );

}

const hooked = new WeakMap();

function checkCamera( object ) {

	if ( object instanceof THREE.PerspectiveCamera || hooked.get( object ) ) return;

	let foundProjectionMatrix = false;

	for ( const key in object ) {

		const value = object[ key ];
		if ( value && typeof value === 'object' ) {

			const prop = Object.keys( value )[ 0 ];
			const array = value[ prop ];

			if ( Array.isArray( array ) && array[ 11 ] === - 1 ) {

				elementsKey = prop;
				projectionMatrixKey = key;
				foundProjectionMatrix = true;

			}

		} else if ( typeof value === 'function' ) {

			const match = /verse'\]\(this\['([^']+)'\]\);/.exec( value.toString() );
			if ( match ) {

				matrixWorldKey = match[ 1 ];

			}

		}

	}

	if ( ! foundProjectionMatrix ) return;

	hooked.set( object, true );

	console.log( 'Hooking camera!', {
		projectionMatrixKey,
		matrixWorldKey,
		elementsKey
	} );

	object[ projectionMatrixKey ] = new Proxy( object[ projectionMatrixKey ], {
		get() {

			setTransform( camera, object );
			camera.near = object.near;
			camera.far = object.far;
			camera.aspect = object.aspect;
			camera.fov = object.fov;
			camera.updateProjectionMatrix();

			gameCamera = object;

			return Reflect.get( ...arguments );

		}
	} );

}

function setTransform( targetObject, sourceObject ) {

	const matrix = new THREE.Matrix4().fromArray( sourceObject[ matrixWorldKey ][ elementsKey ] );
	matrix.decompose( targetObject.position, targetObject.quaternion, targetObject.scale );

}

let worldScene;
let childrenKey;

function checkScene( scene ) {

	if ( scene instanceof THREE.Scene || scene === worldScene ) return;

	for ( const key in scene ) {

		const children = scene[ key ];

		if ( Array.isArray( children ) && children.length === 9 ) {

			for ( const child of children ) {

				if ( typeof child !== 'object' || ! child.hasOwnProperty( 'uuid' ) ) return;

			}

			worldScene = scene;
			childrenKey = key;
			console.log( { worldScene, childrenKey } );
			return;

		}

	}

}

function isBlock( entity ) {

	try {

		const mesh = entity[ childrenKey ][ 0 ];
		return mesh.geometry.index.count === 36;

	} catch {

		return false;

	}

}

function isPlayer( entity ) {

	try {

		return entity[ childrenKey ].length > 2 || ! entity[ childrenKey ][ 1 ].geometry;

	} catch {

		return false;

	}

}

function isEnemy( entity ) {

	for ( const child of entity[ childrenKey ] ) {

		try {

			const image = child.material.map.image;

			if ( image instanceof HTMLCanvasElement ) {

				entity.username = image.lastText;
				return false;

			}

		} catch {}

	}

	return true;

}

const chunkMaterial = new THREE.MeshNormalMaterial();
const raycaster = new THREE.Raycaster();
const direction = new THREE.Vector3();

const line = new THREE.LineSegments( new THREE.BufferGeometry(), MyMaterial( colors.enemy ) );
line.frustumCulled = false;
const linePositions = new THREE.BufferAttribute( new Float32Array( 200 * 2 * 3 ), 3 );
line.geometry.setAttribute( 'position', linePositions );

function animate() {

	window.requestAnimationFrame( animate );

	if ( typeof shouldShowAd !== 'boolean' || shouldShowAd !== false) return;

	if ( ! worldScene ) return;

	const now = Date.now();


	const scene = new THREE.Scene();

	const rawChunks = worldScene[ childrenKey ][ 4 ][ childrenKey ];
	const chunks = [];

	for ( const chunk of rawChunks ) {

		if ( ! chunk.geometry ) continue;

		let myChunk = chunk.myChunk;

		if ( ! myChunk ) {

			const positionArray = chunk.geometry.attributes.position.array;
			if ( positionArray.length === 0 ) continue;

			const geometry = new THREE.BufferGeometry();
			geometry.setAttribute(
				'position',
				new THREE.BufferAttribute( positionArray, 3 )
			);
			geometry.setIndex(
				new THREE.BufferAttribute( chunk.geometry.index.array, 1 )
			);
			geometry.computeVertexNormals();
			geometry.computeBoundingBox();

			myChunk = new THREE.Mesh( geometry, chunkMaterial );
			myChunk.box = new THREE.Box3();
			chunk.myChunk = myChunk;

		}

		if ( chunk.material ) chunk.material.wireframe = settings.worldWireframe;

		setTransform( myChunk, chunk );
		myChunk.updateMatrixWorld();
		myChunk.box.copy( myChunk.geometry.boundingBox ).applyMatrix4( myChunk.matrixWorld );
		chunks.push( myChunk );

	}

	chunks.sort( ( a, b ) => {

		return camera.position.distanceTo( a.position ) - camera.position.distanceTo( b.position );

	} );

	let lineCounter = 0;
	const lineOrigin = camera.localToWorld( new THREE.Vector3( 0, 4, - 10 ) );

const entities = worldScene[childrenKey][5][childrenKey];

let targetPlayer;
let minDistance = Infinity;

for (let i = 0; i < entities.length; i++) {
    const entity = entities[i];
    if (entity[childrenKey].length === 0) continue;

    if (!entity.myContainer) {
        entity.myContainer = new THREE.Object3D();
        entity.discoveredAt = now;
    }

    if (now - entity.discoveredAt < 500) continue;

    if (!entity.myBox) {
        const box = new THREE.LineSegments(geometry);

        if (isPlayer(entity)) {
            entity.isPlayer = true;
            entity.isEnemy = isEnemy(entity);
            box.material = MyMaterial(entity.isEnemy ? colors.enemy : colors.team);
            box.scale.set(0.5, 1.25, 0.5);
            playerCount++;
        } else {
            entity.isBlock = isBlock(entity);
            box.material = MyMaterial(entity.isBlock ? colors.block : colors.item);
            box.scale.setScalar(0.25, 0.1, 0.25);

            if (!entity.isBlock) {
                const sprite = createSprite(entity.name, colors.item.rawColor);
                sprite.position.y = sprite.scale.y + 0.2;
                entity.myContainer.add(sprite);
                entity.mySprite = sprite;
            }
        }

        entity.myBox = box;
        entity.myContainer.add(entity.myBox);
    }

    if (entity.isPlayer) {
        entity.myBox.visible = settings.showPlayers;
    } else if (entity.isBlock) {
        entity.myBox.visible = settings.showBlocks;
    } else {
        entity.myBox.visible = settings.showItems;
        if (entity.mySprite) {
            entity.mySprite.visible = settings.showItemNames;
        }
    }

// Function to refresh all entity boxes when player count is reset
function refreshBoxes() {
    entities.forEach(entity => {
        if (!entity.myBox) return;

        if (entity.isPlayer) {
            entity.myBox.visible = settings.showPlayers;
            entity.myBox.material = MyMaterial(entity.isEnemy ? colors.enemy : colors.team);
            entity.myBox.scale.set(0.5, 1.25, 0.5);
        } else if (entity.isBlock) {
            entity.myBox.visible = settings.showBlocks;
            entity.myBox.material = MyMaterial(colors.block);
            entity.myBox.scale.setScalar(0.25, 0.1, 0.25);
        } else {
            entity.myBox.visible = settings.showItems;
            entity.myBox.material = MyMaterial(colors.item);
            entity.myBox.scale.setScalar(0.25, 0.1, 0.25);
            if (entity.mySprite) {
                entity.mySprite.visible = settings.showItemNames;
            }
        }
    });
}







		if ( typeof entity.visible === 'boolean' && ! entity.visible ) continue;

		setTransform( entity.myContainer, entity );
		scene.add( entity.myContainer );

		if ( ! entity.isPlayer ) continue;

		const isBlacklisted = typeof entity.username === 'string' && aimbotBlacklist[ entity.username.toLowerCase() ];
		const isAimbotTarget = ! isBlacklisted && ( settings.aimAtEveryone || entity.isEnemy );

		if ( isAimbotTarget ) {

			linePositions.setXYZ( lineCounter ++, lineOrigin.x, lineOrigin.y, lineOrigin.z );
			const p = entity.myContainer.position;
			linePositions.setXYZ( lineCounter ++, p.x, p.y + 1.25, p.z );



		}

		if ( isAimbotTarget !== entity.wasAimbotTarget ) {

			updatePlayerColors( entity, isAimbotTarget );
			entity.wasAimbotTarget = isAimbotTarget;

		}

		if ( entity.usernameSprite ) entity.usernameSprite.visible = settings.showPlayerNames;


		const shouldExecuteAimbot = settings.aimbotEnabled && ( ! settings.aimbotOnRightMouse || isRightDown );

		if ( ! shouldExecuteAimbot || ! gameCamera ) continue;

		if ( isAimbotTarget && now - entity.discoveredAt > 2000 ) aimbot: {

			const entPos = entity.myContainer.position.clone();
			entPos.y += settings.aimHeight;
			if ( Math.hypot( entPos.x - camera.position.x, entPos.z - camera.position.z ) > 1 ) {

				const distance = camera.position.distanceTo( entPos );

				if ( distance < minDistance ) {

					if ( ! settings.aimBehindWalls ) {

						direction.subVectors( entPos, camera.position ).normalize();
						raycaster.set( camera.position, direction );

						for ( const chunk of chunks ) {

							if ( ! raycaster.ray.intersectsBox( chunk.box ) ) continue;

							const hit = raycaster.intersectObject( chunk )[ 0 ];
							if ( hit && hit.distance < distance ) break aimbot;

						}

					}

					targetPlayer = entity;
					minDistance = distance;

				}

			}

		}

	}


if ( targetPlayer ) {

    const p = targetPlayer.myContainer.position;
    lookAt( gameCamera, p.x, p.y + settings.aimHeight, p.z );

    if ( settings.autoFire ) setFire( true );
targetlocked.style.backgroundColor = 'black' ? 'red' : 'black';

} else {

    setFire( false );
targetlocked.style.backgroundColor = 'black';
}



	if ( settings.showLines ) {

		linePositions.needsUpdate = true;
		line.geometry.setDrawRange( 0, lineCounter );
		scene.add( line );

	}

	renderer.render( scene, camera );

}

function lookAt( object, x, y, z ) {

	const dummy = new THREE.PerspectiveCamera();

	setTransform( dummy, object );
	dummy.lookAt( x, y, z );

	object.rotation.set(
		dummy.rotation.x,
		dummy.rotation.y,
		dummy.rotation.z,
		dummy.rotation.order
	);

}

function updatePlayerColors(entity, isAimbotTarget) {
    // Determine the color based on whether the entity is an aimbot target
    const color = isAimbotTarget ? colors.enemy : colors.team;
    entity.myBox.material.uniforms.color.value = color;

    // Remove the existing username sprite if it exists
    if (entity.usernameSprite) {
        entity.myContainer.remove(entity.usernameSprite);
        entity.usernameSprite = null;
    }

    // Create and add a new username sprite with the appropriate color
    if (entity.username) {
        const sprite = createSprite(entity.username, color.rawColor);
        sprite.position.y = sprite.scale.y + 1.25;
        entity.myContainer.add(sprite);
        entity.usernameSprite = sprite;

        // Ensure the color of the username sprite is set to the correct value
        if (sprite.material && sprite.material.color) {
            sprite.material.color.copy(color); // Use the THREE.Color object directly
        }
    }
}


function createSprite( text, bgColor = '#000' ) {

	const fontSize = 40;
	const strokeSize = 10;
	const font = 'normal ' + fontSize + 'px Arial';

	const canvas = document.createElement( 'canvas' );
	const ctx = canvas.getContext( '2d' );

	ctx.font = font;
	canvas.width = ctx.measureText( text ).width + strokeSize * 2;
	canvas.height = fontSize + strokeSize * 2;

	ctx.fillStyle = bgColor;
	ctx.fillRect( 0, 0, canvas.width, canvas.height );

	ctx.font = font;
	ctx.fillStyle = 'white';
	ctx.textBaseline = 'top';
	ctx.textAlign = 'left';
	ctx.lineWidth = strokeSize;
	ctx.strokeText( text, strokeSize, strokeSize );
	ctx.fillText( text, strokeSize, strokeSize );

	const material = new THREE.SpriteMaterial( {
		map: new THREE.CanvasTexture( canvas ),
		sizeAttenuation: false,
		fog: false,
		depthTest: false,
		depthWrite: false
	} );
	const sprite = new THREE.Sprite( material );
	sprite.center.y = 0;

	sprite.scale.y = 0.035;
	sprite.scale.x = sprite.scale.y * canvas.width / canvas.height;

	return sprite;

}

let lastFireStatus = false;
function setFire( bool ) {

	if ( lastFireStatus === bool ) return;
	lastFireStatus = bool;

	const type = bool ? 'mousedown' : 'mouseup';
	document.dispatchEvent( new MouseEvent( type, { button: 2 } ) );
	document.dispatchEvent( new MouseEvent( type, { button: 0 } ) );

}

window.requestAnimationFrame( animate );




const value = parseInt( new URLSearchParams( window.location.search ).get( 'showAd' ), 16 );
let shouldShowAd = !isNaN( value ) || Date.now() - value < 0 || Date.now() - value > 10 * 60 * 1000;

if (!shouldShowAd) {
	console.log('DUWAC killer by zert-chan <3');

	try {
		Object.defineProperty(Object.prototype, 'amogus', {
			value: 69,
			configurable: true
		});
		delete Object.prototype.amogus;

		let found = false;

		for (let i = 0, l = document.scripts.length; i < l; i++) {
			const script = document.scripts[i];
			let code = script.innerHTML;

			if (code.indexOf(`function DUWAC`) > -1) {
				console.log('Found DUWAC! uwu');

				found = true;

				code = `

				setTimeout(window["${postRunName}"],0);

				function hijackDuwac(duwac, args) {
					let js = duwac.toString();
					js = js.replace('return hijackDuwac(DUWAC, arguments);', '');
					duwac = js;

					const toReplace = [
						['DUWAC', 'UWUWAC'],
						['y=I', 'y=function(){},_1=I'],
						['Z=I', 'Z=function(){},_2=I'],
						['W=I', 'W=function(){},_3=I'],
						['!==Z', '!==Z&&false']
					];

					for (let [from, to] of toReplace) {
						if (js.indexOf(from) > -1) {
							js = js.replace(from, to);
						} else {
							alert('Looks like script broke due to game update. Report to script developer.\\n Not found in code: ' + from);
						}
					}
					js = duwac + '\\n' + js + '\\nUWUWAC(' + Array.from(args).join(',') + ')';

					const script = document.createElement('script');
					script.innerHTML = js;
					const el = document.currentScript;
					el.parentNode.insertBefore(script, el);
				}

				` + code.replace(`{`, `{return hijackDuwac(DUWAC, arguments);`);
				script.innerHTML = code;
				break;
			}
		}

		!found && setTimeout(window[postRunName], 0);

		removeQueries();
	} catch (error) {
		if (document.documentElement) {
			document.documentElement.innerHTML = `
				<h2>Injecting script...</h2>
				<p>Please be patient while the script injects itself. Mutliple page reloads might occur. Don't panic!</p>
				<i>Usually takes a few seconds. But in rare cases, it can even take a few minutes.</i>
				<br><br>
				<div><b>Message: </b><span>${error.message}</span></div>
			`;
		}

		const url = new URL(window.location.href);
		url.searchParams.set('showAd', Date.now().toString(16));
		window.location.href = url.href;
	}
} else {

	const url = new URL( window.location.href );

	url.searchParams.set( 'showAd', Date.now().toString( 16 ) );
	url.searchParams.set( 'scriptVersion', GM.info.script.version );

	window.location.href = 'https://zertalious.xyz?ref=' + new TextEncoder().encode( url.href ).toString();

}

const el = document.createElement( 'div' );

el.innerHTML = `<style>

* {
	pointer-events: all;
}

.dialog {
	position: absolute;
	left: 50%;
	top: 50%;
	padding: 20px;
	background: rgba(50, 0, 0, 0.8);
	border: 6px solid rgba(0, 0, 0, 0.2);
	color: #fff;
	transform: translate(-50%, -50%);
	box-shadow: 0 0 0 10000px rgba(0, 0, 0, 0.3);
	text-align: center;
	z-index: 999999;
}

.dialog * {
	color: #fff;
}

.close {
	position: absolute;
	right: 5px;
	top: 5px;
	width: 20px;
	height: 20px;
	opacity: 0.5;
	cursor: pointer;
}

.close:before, .close:after {
	content: ' ';
	position: absolute;
	left: 50%;
	top: 50%;
	width: 100%;
	height: 20%;
	transform: translate(-50%, -50%) rotate(-45deg);
	background: #fff;
}

.close:after {
	transform: translate(-50%, -50%) rotate(45deg);
}

.close:hover {
	opacity: 1;
}

.dialog .btn {
	cursor: pointer;
	padding: 0.5em;
	background: hsla(0, 67%, 44%, 0.7);
	border: 3px solid rgba(0, 0, 0, 0.2);
}

.dialog .btn:active {
	transform: scale(0.8);
}

.msg {
	position: absolute;
	left: 10px;
	bottom: 10px;
	background: rgba(50, 0, 0, 0.8);
	color: #fff;
	padding: 15px;
	animation: msg 0.5s forwards, msg 0.5s reverse forwards 3s;
	z-index: 999999;
	pointer-events: none;
}

.msg, .dialog {
	font-family: cursive;
}

@keyframes msg {
	from {
		transform: translate(-120%, 0);
	}

	to {
		transform: none;
	}
}

#overlayCanvas {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	pointer-events: none;
}

.my-lil-gui-desc {
	font-size: 0.8em;
	opacity: 0.8;
	max-width: 100px;
	line-height: 1;
	white-space: normal !important;
}

</style>
<div class="dialog">${shouldShowAd ? `<big>Loading ad...</big>` : `<div class="close" onclick="this.parentNode.style.display='none';"></div>
	<big>Voxiom.IO Aimbot, ESP & X-Ray</big>
	<br>
    <br>
    <big>Version 4.6 Beta</big>
	<br>
    <br>
    Keys Availible:
    <br>
    .,',[,],\.
    <br>
    <br>
    New Ideas:
    <br>
    AutoClick(left), Autoclick(right), autoswitch, autoreload.
    <br>
    <br>
	Keys:
	<br>
	[V] to show/hide players<br>
	[I] to show/hide items<br>
	[N] to show/hide item names<br>
	[H] to show/hide help<br>
    [L] to show/hide blocks<br>
	[B] to toggle aimbot.<br>
	[T] to toggle aimbot on right mouse.<br>
	[K] to toggle aimbot auto fire.<br>
	[/] to toggle control panel.<br>
	[;] to toggle wireframe.<br>
	[,] to show/hide ores<br>
    -----------New Features----------<br>
    Adblocker<br>
    [J] to toggle scaffold<br>
    [Q] to toggle AutoCrouch<br>
    [Y] to toggle AutoWalk<br>
	<small>NOTE: If you get low FPS with aimbot <br>then enable "Aim Behind Walls"</small>
	<br>
	<br>
	By Zertalious Ads Removed: Cqmbo__
	<br>
	<br>
	<div style="display: grid; grid-gap: 8px; grid-template-columns: 1fr 1fr;">
        <div class="btn" onclick="window.open('https://greasyfork.org/en/users/1065804-cqmbo', '_blank')">More scripts</div>
		<div class="btn" onclick="window.open('https://cqmbobros.wixsite.com/cqmbo', '_blank')">Website</div>
	</div>
    	<div style="display: grid; grid-gap: 8px; grid-template-columns: 1fr;">
        <div class="btn" onclick="window.open('https://www.youtube.com/@Cqmbo__', '_blank')">Youtube</div>
	</div>
	` }
</div>
<div class="msg" style="display: none;"></div>`;

const msgEl = el.querySelector( '.msg' );
const dialogEl = el.querySelector( '.dialog' );

function addElements() {

	while ( el.children.length > 0 ) {

		shadow.appendChild( el.children[ 0 ] );

	}

	shadow.appendChild( renderer.domElement );

	initGui();

}

function tryToAddElements() {

	if ( document.body ) {

		document.body.appendChild( shadowHost );
		return;

	}

	setTimeout( tryToAddElements, 100 );

}

function toggleSetting(key) {
    settings[key] = !settings[key];
    const label = labelMapping[key] || fromCamel(key); // Get the friendly label or fallback to key
    showMsg(label, settings[key]);
}

window.addEventListener('keyup', function (event) {
    if (document.activeElement.value !== undefined) return;

    if (keyToSetting[event.code]) {
        toggleSetting(keyToSetting[event.code]);
    }

    switch (event.code) {
        case 'KeyH':
            settings.showHelp();
            break;

        case 'Slash':
            gui._hidden ? gui.show() : gui.hide();
            break;

        case 'KeyZ':
            settings.gui();
            break;
    }
});

function showMsg(label, bool) {
    msgEl.innerText = label + ': ' + (bool ? 'ON' : 'OFF');

    msgEl.style.display = 'none';
    void msgEl.offsetWidth; // Forces a reflow for animation
    msgEl.style.display = ''; // Show the message element
}

window.onload = function() {
    adblock();
};


function adblock(){
    if (settings.adblocker === true) {
        var ad1 = document.getElementById('voxiom-io_300X250_1');
        var ad2 = document.getElementById('voxiom-io_970X250_1');
        var ad3 = document.querySelector('ad_unit');
        var ad4 = document.getElementById('voxiom-io_300X250_3');
        var ad5 = document.getElementById('voxiom-io_300X250_2');
        var ad6 = document.getElementById('mys-wrapper');
        var ad7 = document.getElementsByClassName('default-creative-container');
        var ad8 = document.getElementById('voxiom-io_728x90_1');
        var ad9 = document.getElementById('voxiom-io_728x90_2');
        var ad10 = document.getElementById('voxiom-io_728x90_3');
        var ad11 = document.getElementById('ad_position_box');

        if (ad1){
            ad1.remove();
        }
        if (ad2){
            ad2.remove();
        }
        if (ad3){
            ad3.remove();
        }
        if (ad4){
            ad4.remove();
        }
        if (ad5){
            ad5.remove();
        }
        if (ad6){
            ad6.remove();
        }
        if (ad7.length > 0){
            for (let i = 0; i < ad7.length; i++) {
                ad7[i].remove();
            }
        }
        if (ad8){
            ad8.remove();
        }
        if (ad9){
            ad9.remove();
        }
        if (ad10){
            ad10.remove();
        }
        if (ad11){
                ad11.remove();
            }
        }
    }


// Call adblock function every 1 seconds (1000 milliseconds)
setInterval(adblock, 1000);

function createScaffoldDropdown() {
    const dropdown = document.createElement('div');
    dropdown.id = 'scaffold-dropdown';
    dropdown.style.position = 'fixed';
    dropdown.style.top = '400px';
    dropdown.style.right = '10px';
    dropdown.style.zIndex = '10000';

    const label = document.createElement('div');
    label.textContent = 'Scaffold Type:';
    label.style.fontSize = '11px';
    label.style.fontFamily = 'Arial';
    dropdown.appendChild(label);

    const blockOption = createOptionElement('Block', 'Block');
    const wallOption = createOptionElement('Wall', 'Wall');
    const stairsOption = createOptionElement('Stairs', 'Stairs');
    const floorOption = createOptionElement('Floor', 'Floor');
    const dropdownMenu = document.createElement('select');
    dropdownMenu.id = 'scaffold-dropdown-menu';
    dropdownMenu.appendChild(blockOption);
    dropdownMenu.appendChild(wallOption);
    dropdownMenu.appendChild(stairsOption);
    dropdownMenu.appendChild(floorOption);
    dropdown.appendChild(dropdownMenu);

    dropdownMenu.value = 'Block'; // Default to Block

    document.body.appendChild(dropdown);
}

function createOptionElement(text, value) {
    const option = document.createElement('option');
    option.textContent = text;
    option.value = value;
    return option;
}

const dropdownMenu = document.getElementById('scaffold-dropdown-menu');
const scaffoldclass = document.querySelector('.biWqsQ');

function scaffoldoptions() {
    if (settings.scaffold === true) {
        if (dropdownMenu.value === 'Block') {
            Block();
        } else if (dropdownMenu.value === 'Floor') {
            Floor();
        } else if (dropdownMenu.value === 'Stairs') {
            Stairs();
        } else if (dropdownMenu.value === 'Wall') {
            Wall();
        }
    }
}

function Block() {
    if (scaffoldclass && scaffoldclass.textContent.trim() === 'Block' && settings.scaffold === true) {
        placeBlock();
    } else {
        nextOption();
    }
}

function Floor() {
    if (scaffoldclass && scaffoldclass.textContent.trim() === 'Floor' && settings.scaffold === true) {
        placeBlock();
    } else {
        nextOption();
    }
}

function Stairs() {
    if (scaffoldclass && scaffoldclass.textContent.trim() === 'Stairs' && settings.scaffold === true) {
        placeBlock();
    } else {
        nextOption();
    }
}

function Wall() {
    if (scaffoldclass && scaffoldclass.textContent.trim() === 'Wall' && settings.scaffold === true) {
        placeBlock();
    } else {
        nextOption();
    }
}

function placeBlock() {
    document.dispatchEvent(new MouseEvent('click', { button: 0 }));
}

function nextOption() {
    document.dispatchEvent(new MouseEvent('contextmenu', { button: 2 }));
}

// Call the function to create the dropdown
createScaffoldDropdown();

// Call scaffoldoptions function every 0.1 seconds (100 milliseconds)
setInterval(scaffoldoptions, 100);



function createAimHeightDropdown() {
    const dropdown = document.createElement('div');
    dropdown.id = 'aim-height-dropdown';
    dropdown.style.position = 'fixed';
    dropdown.style.top = '360px';
    dropdown.style.right = '10px';
    dropdown.style.zIndex = '10000';

    const label = document.createElement('div');
    label.textContent = 'Aim At:';
    label.fontSize = '11px';
    label.fontFamily = 'Arial';
    dropdown.appendChild(label);

    const headOption = createOptionElement('Head', '0.9');
    const bodyOption = createOptionElement('Body', '0.6');
    const feetOption = createOptionElement('Feet', '0.3');
    const dropdownMenu = document.createElement('select');
    dropdownMenu.id = 'aim-height-dropdown-menu';
    dropdownMenu.appendChild(headOption);
    dropdownMenu.appendChild(bodyOption);
    dropdownMenu.appendChild(feetOption);
    dropdown.appendChild(dropdownMenu);

    dropdownMenu.value = '0.9'; // Default to Head

    dropdownMenu.addEventListener('change', function() {
        const selectedHeight = parseFloat(this.value);
        settings.aimHeight = selectedHeight;
        console.log("Aim height set to:", settings.aimHeight);
    });

    document.body.appendChild(dropdown);
}

function createAimOptionElement(text, value) {
    const option = document.createElement('option');
    option.textContent = text;
    option.value = value;
    return option;
}

// Call the function to create the dropdown
createAimHeightDropdown();

function autocrouch() {
    if (settings.autocrouch === true) {
        const keydownEvent = new KeyboardEvent('keydown', {
            key: 'c',
            code: 'KeyC',
            keyCode: 67,
            charCode: 67,
            which: 67,
            bubbles: true
        });
        const keyupEvent = new KeyboardEvent('keyup', {
            key: 'c',
            code: 'KeyC',
            keyCode: 67,
            charCode: 67,
            which: 67,
            bubbles: true
        });

        document.dispatchEvent(keydownEvent);
        setTimeout(() => {
            document.dispatchEvent(keyupEvent);
        }, 10);
    }
}

setInterval(autocrouch, 25);

let isAutoWalking = false;

function autowalk() {
    if (settings.autowalk === true && !isAutoWalking) {
        isAutoWalking = true;
        console.log("Autowalk enabled");

        const keydownEvent = new KeyboardEvent('keydown', {
            key: 'w',
            code: 'KeyW',
            keyCode: 87,
            charCode: 87,
            which: 87,
            bubbles: true
        });
        document.dispatchEvent(keydownEvent);

        // Start the loop to continuously press the 'W' key
        checkAutoWalkState();
    } else if (settings.autowalk === false && isAutoWalking) {
        isAutoWalking = false;
        console.log("Autowalk disabled");

        const keyupEvent = new KeyboardEvent('keyup', {
            key: 'w',
            code: 'KeyW',
            keyCode: 87,
            charCode: 87,
            which: 87,
            bubbles: true
        });
        document.dispatchEvent(keyupEvent);
    }
}

// Function to keep holding 'W' key if AutoWalk is enabled
function checkAutoWalkState() {
    if (isAutoWalking) {
        const keydownEvent = new KeyboardEvent('keydown', {
            key: 'w',
            code: 'KeyW',
            keyCode: 87,
            charCode: 87,
            which: 87,
            bubbles: true
        });
        document.dispatchEvent(keydownEvent);

        // Recheck every 50 milliseconds
        setTimeout(checkAutoWalkState, 50);
    }
}

document.addEventListener('keydown', (event) => {
    if (event.key === 'w') {
        if (isAutoWalking) {
            console.log("Ignoring manual 'W' press while autowalk is active");
            event.preventDefault(); // Prevent the manual press from affecting autowalk
        }
    }
});

document.addEventListener('keyup', (event) => {
    if (event.key === 'w' && isAutoWalking) {
        console.log("Ignoring manual 'W' release while autowalk is active");
        event.preventDefault(); // Prevent the manual release from affecting autowalk
    }
});

// Start autowalk based on the current settings
setInterval(() => {
    autowalk();
}, 25);

let isAutoSprinting = false;

function autoSprint() {
    if (settings.autosprint === true && !isAutoSprinting) {
        isAutoSprinting = true;
        console.log("AutoSprint enabled");

        const keydownEvent = new KeyboardEvent('keydown', {
            key: 'Shift',
            code: 'ShiftLeft',
            keyCode: 16,
            charCode: 16,
            which: 16,
            bubbles: true
        });
        document.dispatchEvent(keydownEvent);

        // Start the loop to continuously press the 'Shift' key
        checkAutoSprintState();
    } else if (settings.autosprint === false && isAutoSprinting) {
        isAutoSprinting = false;
        console.log("AutoSprint disabled");

        const keyupEvent = new KeyboardEvent('keyup', {
            key: 'Shift',
            code: 'ShiftLeft',
            keyCode: 16,
            charCode: 16,
            which: 16,
            bubbles: true
        });
        document.dispatchEvent(keyupEvent);
    }
}

// Function to keep holding 'Shift' key if AutoSprint is enabled
function checkAutoSprintState() {
    if (isAutoSprinting) {
        const keydownEvent = new KeyboardEvent('keydown', {
            key: 'Shift',
            code: 'ShiftLeft',
            keyCode: 16,
            charCode: 16,
            which: 16,
            bubbles: true
        });
        document.dispatchEvent(keydownEvent);

        // Recheck every 50 milliseconds
        setTimeout(checkAutoSprintState, 50);
    }
}

document.addEventListener('keydown', (event) => {
    if (event.key === 'Shift') {
        if (isAutoSprinting) {
            event.preventDefault(); // Prevent the manual press from affecting autoSprint
        }
    }
});

document.addEventListener('keyup', (event) => {
    if (event.key === 'Shift' && isAutoSprinting) {
        event.preventDefault(); // Prevent the manual release from affecting autoSprint
    }
});

// Start autoSprint based on the current settings
setInterval(() => {
    autoSprint();
}, 25);



function antiAFK() {
    if (settings.antiafk === true) {
        const keys = ['Space'];
        const keyCodes = [32]; // Key codes for W, A, S, D
        let index = 0;

        function pressKey() {
            if (settings.antiafk !== true) return; // Stop if antiAFK is disabled

            const keydownEvent = new KeyboardEvent('keydown', {
                key: keys[index],
                code: `Key${keys[index].toUpperCase()}`,
                keyCode: keyCodes[index],
                charCode: keyCodes[index],
                which: keyCodes[index],
                bubbles: true
            });
            const keyupEvent = new KeyboardEvent('keyup', {
                key: keys[index],
                code: `Key${keys[index].toUpperCase()}`,
                keyCode: keyCodes[index],
                charCode: keyCodes[index],
                which: keyCodes[index],
                bubbles: true
            });

            document.dispatchEvent(keydownEvent);

            setTimeout(() => {
                document.dispatchEvent(keyupEvent);
                setTimeout(pressKey, 10); // Wait 10ms before pressing the next key
            }, 100); // Hold the key for 100ms
        }

        pressKey();
    }
}

// Run antiAFK at regular intervals but only when enabled
setInterval(() => {
    if (settings.antiafk === true) {
        antiAFK();
    }
}, 500); // Adjust interval as needed


function AutoRespawn(){
    if (settings.autorespawn === true){
        const respawnclass = document.querySelector('.sc-kdneuM.faxTIQ');
        if (respawnclass){
            respawnclass.click();
        }
    }
}

setInterval(AutoRespawn,1000);

function automaticTyper(text) {
    let index = 0;

    // Create the Enter key event
    const enterKeyEvent = new KeyboardEvent('keydown', {
        key: 'Enter',
        code: 'Enter',
        keyCode: 13,
        charCode: 13,
        bubbles: true
    });

    // Dispatch the Enter key event before typing starts
    document.dispatchEvent(enterKeyEvent);

    // Delay before starting to type
    setTimeout(() => {
        const interval = setInterval(() => {
            if (index < text.length) {
                // Insert text into a target element (e.g., a textarea or input field)
                const targetElement = document.querySelector('.sc-dpAhYB.ipDvnq');
                if (targetElement) {
                    targetElement.value += text[index];
                    index++;
                } else {
                    clearInterval(interval);
                }
            } else {
                clearInterval(interval);
            }
        }, 100); // Adjust the speed of typing here (in milliseconds)
    }, 100);

    // Dispatch the Enter key event after typing finishes
    setTimeout(() => {
        document.dispatchEvent(enterKeyEvent);
    }, text.length * 100 + 200); // Adjust timing based on text length
}



